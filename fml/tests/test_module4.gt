type Idx(@Self, @Output) = struct
    idx: fn(@Self, I32): @Output,
end

type List(@T) = struct
    dummy_data: @T,
end


-- TODO: For some reason this works, even though Foo
-- is a bad type and Bar doesn't match it.
const BadIntListIdx = $Idx(List(I32), Foo) {
    .idx = fn(self: List(I32), i: I32): Bar = self.dummy_data end
}

-- What if we mistype the interface for Idx(List(_) _)?
-- Oops
const TerribleIntListIdx = $Idx(List(I32), I32) {
    .idx = fn(self: I32, i: I32): List(I32) =
        $List(I32) { .dummy_data = 3 }
    end
}

-- What if we use it with an invalid type arg?
-- Oops.
fn bad_sum(l: List(@T)): I32 =
    let total: I32 = 3
    BadIntListIdx.idx(true, total)
end
